package uk.gov.hmcts.cp.filter.audit;

import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import com.fasterxml.jackson.databind.JsonNode;
import org.apache.activemq.artemis.api.core.TransportConfiguration;
import org.apache.activemq.artemis.core.config.impl.ConfigurationImpl;
import org.apache.activemq.artemis.core.remoting.impl.netty.NettyAcceptorFactory;
import org.apache.activemq.artemis.core.server.JournalType;
import org.apache.activemq.artemis.core.server.embedded.EmbeddedActiveMQ;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;

abstract class AbstractEmbeddedArtemisTest {
    private static final org.slf4j.Logger LOG =
            org.slf4j.LoggerFactory.getLogger(AbstractEmbeddedArtemisTest.class);

    protected static EmbeddedActiveMQ broker;
    protected static int port;
    /**
     * URL for test consumer (BrokerUtil)
     */
    protected static String brokerUrlForConsumer;
    /**
     * URL for the starter (published as cp.audit.url)
     */
    protected static String producerUrlForStarter;

    // ---- SSL material (generated by Gradle into classpath: ssl/*) ----
    protected static final String STORE_PASSWORD = "changeit";
    protected static final String TRUSTSTORE_CLASSPATH = "ssl/truststore.jks";
    protected static final String KEYSTORE_CLASSPATH = "ssl/keystore.jks";
    protected static Path truststorePath;
    protected static Path keystorePath;

    protected Duration consumerWait() {
        return Duration.ofSeconds(10);
    }

    // ---- SSL flag control used by subclasses ----
    private static boolean sslEnabledMemo = false;

    protected static void setSslEnabledStatic(boolean enabled) {
        sslEnabledMemo = enabled;
    }

    protected static boolean sslEnabledStatic() {
        return sslEnabledMemo;
    }

    @BeforeAll
    static void baseNoop() {
    }

    @AfterAll
    static void stopBroker() throws Exception {
        if (broker != null) broker.stop();
        safeDelete(truststorePath);
        safeDelete(keystorePath);
    }

    /**
     * Start a single embedded Artemis broker (plain or TLS).
     */
    protected static void startEmbedded(boolean enableSsl) throws Exception {
        setSslEnabledStatic(enableSsl);

        if (enableSsl) {
            truststorePath = copyToTemp(TRUSTSTORE_CLASSPATH);
            keystorePath = copyToTemp(KEYSTORE_CLASSPATH);
        }

        port = findFreePort();

        final org.apache.activemq.artemis.core.config.Configuration cfg = new ConfigurationImpl()
                .setSecurityEnabled(false)
                .setPersistenceEnabled(false)
                .setJMXManagementEnabled(false)
                .setJournalType(JournalType.NIO);

        // Isolate broker dirs under tmp
        cfg.setBindingsDirectory(Files.createTempDirectory("artemis-bindings").toString());
        cfg.setJournalDirectory(Files.createTempDirectory("artemis-journal").toString());
        cfg.setLargeMessagesDirectory(Files.createTempDirectory("artemis-large").toString());
        cfg.setPagingDirectory(Files.createTempDirectory("artemis-paging").toString());

        // Acceptor params — use 'localhost' to match CN in the generated cert
        Map<String, Object> params = new HashMap<>();
        params.put("host", "localhost");
        params.put("port", port);

        if (enableSsl) {
            params.put("sslEnabled", true);
            params.put("sslProvider", "JDK");
            params.put("protocols", "TLSv1.3,TLSv1.2");
            params.put("keyStorePath", keystorePath.toString());
            params.put("keyStorePassword", STORE_PASSWORD);
            params.put("trustStorePath", truststorePath.toString());
            params.put("trustStorePassword", STORE_PASSWORD);
            params.put("needClientAuth", false);
        }

        TransportConfiguration acceptor = new TransportConfiguration(
                NettyAcceptorFactory.class.getName(),
                params,
                enableSsl ? "tls-acceptor" : "tcp-acceptor"
        );
        cfg.getAcceptorConfigurations().add(acceptor);

        broker = new EmbeddedActiveMQ();
        broker.setConfiguration(cfg);
        broker.start();
        broker.getActiveMQServer().waitForActivation(10, TimeUnit.SECONDS);

        // Build a client URL that does NOT wait for HA topology (single broker)
        String base = "tcp://localhost:" + port
                + "?ha=false"
                + "&retryInterval=100"
                + "&reconnectAttempts=0"
                + "&initialConnectAttempts=10"
                + "&connectionTTL=30000";

        if (enableSsl) {
            base += "&sslEnabled=true"
                    + "&trustStorePath=" + truststorePath
                    + "&trustStorePassword=" + STORE_PASSWORD;
        }

        brokerUrlForConsumer = base; // used by BrokerUtil in tests
        producerUrlForStarter = base; // published as cp.audit.url for your starter
    }

    /**
     * Publish properties so the starter points to this embedded broker.
     */
    @DynamicPropertySource
    static void auditProps(DynamicPropertyRegistry reg) {
        // Keep host/port for existing code paths…
        reg.add("cp.audit.hosts", () -> "localhost");
        reg.add("cp.audit.port", () -> port);
        reg.add("cp.audit.user", () -> "");
        reg.add("cp.audit.password", () -> "");
        reg.add("cp.audit.ssl-enabled", AbstractEmbeddedArtemisTest::sslEnabledStatic);

        // …and also provide a prebuilt URL with ha=false & timeouts.
        reg.add("cp.audit.url", () -> producerUrlForStarter);
        reg.add("cp.audit.ha", () -> false);

        if (sslEnabledStatic()) {
            reg.add("cp.audit.truststore", () -> truststorePath.toString());
            reg.add("cp.audit.truststore-password", () -> STORE_PASSWORD);
        }
    }

    protected static Path copyToTemp(String cp) throws IOException, URISyntaxException {
        var url = Thread.currentThread().getContextClassLoader().getResource(cp);
        if (url == null) throw new IllegalStateException("Missing classpath resource: " + cp);
        Path tmp = Files.createTempFile("artemis-", "-" + Path.of(cp).getFileName());
        Files.copy(Path.of(url.toURI()), tmp, java.nio.file.StandardCopyOption.REPLACE_EXISTING);
        return tmp;
    }

    protected static int findFreePort() throws IOException {
        try (var s = new java.net.ServerSocket(0)) {
            s.setReuseAddress(true);
            return s.getLocalPort();
        }
    }

    protected static void safeDelete(Path p) {
        if (p == null) return;
        try {
            Files.deleteIfExists(p);
        } catch (IOException e) {
            // best-effort cleanup for test temp files; non-fatal if deletion fails
            LOG.debug("Couldn't delete temp file {} (ignored)", p, e);
        }
    }

    // JSON helpers for assertions
    protected static JsonNode mdName(final JsonNode json) {
        return json.get("_metadata").get("name");
    }

    protected static JsonNode origin(final JsonNode json) {
        return json.get("origin");
    }

    protected static JsonNode component(final JsonNode json) {
        return json.get("component");
    }

    protected static JsonNode content(final JsonNode json) {
        return json.get("content");
    }

    protected static JsonNode contentMd(final JsonNode json) {
        return content(json).get("_metadata");
    }

    protected static JsonNode user(final JsonNode json) {
        return contentMd(json).get("context").get("user");
    }

    protected static JsonNode corr(final JsonNode json) {
        return contentMd(json).get("correlation").get("client");
    }

    protected static JsonNode opName(final JsonNode json) {
        return contentMd(json).get("name");
    }
}
